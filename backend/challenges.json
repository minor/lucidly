[
    {
        "id": "cpp-lockfree-stack",
        "title": "Debug: Lock-Free Stack Race Conditions",
        "description": "This lock-free stack implementation uses a simplified Hazard Pointer scheme but crashes under high contention due to race conditions and memory reclamation bugs. Fix the race conditions while maintaining lock-free properties.",
        "category": "debug",
        "difficulty": "hard",
        "starter_code": "#include <atomic>\n#include <vector>\n#include <thread>\n#include <iostream>\n\n// A simplified Hazard Pointer Node\nstruct Node {\n    int value;\n    Node* next;\n    Node(int v) : value(v), next(nullptr) {}\n};\n\n// Global Hazard Pointers (simplified for fixed thread count)\nstd::atomic<Node*> hazard_pointers[100]; \nconst int MAX_THREADS = 100;\n\nclass LockFreeStack {\n    std::atomic<Node*> head{nullptr};\n    std::vector<Node*> retired_nodes; \n    std::atomic<bool> reclaiming{false};\n\npublic:\n    void push(int val) {\n        Node* new_node = new Node(val);\n        new_node->next = head.load(std::memory_order_relaxed);\n        while (!head.compare_exchange_weak(new_node->next, new_node, \n                                           std::memory_order_release, \n                                           std::memory_order_relaxed));\n    }\n\n    bool pop(int& result, int thread_id) {\n        Node* old_head;\n        do {\n            old_head = head.load(std::memory_order_relaxed);\n            if (!old_head) return false;\n            \n            hazard_pointers[thread_id].store(old_head, std::memory_order_seq_cst);\n            \n            if (head.load(std::memory_order_relaxed) != old_head) {\n                hazard_pointers[thread_id].store(nullptr, std::memory_order_relaxed); \n                continue;\n            }\n        } while (!head.compare_exchange_weak(old_head, old_head->next, \n                                             std::memory_order_acquire, \n                                             std::memory_order_relaxed));\n        \n        hazard_pointers[thread_id].store(nullptr, std::memory_order_relaxed);\n        result = old_head->value;\n        retire(old_head);\n        return true;\n    }\n\n    void retire(Node* node) {\n        retired_nodes.push_back(node); \n        \n        if (reclaiming.exchange(true)) return;\n        \n        for (auto it = retired_nodes.begin(); it != retired_nodes.end(); ) {\n            bool hazardous = false;\n            for (int i = 0; i < MAX_THREADS; ++i) {\n                if (hazard_pointers[i].load() == *it) {\n                    hazardous = true;\n                    break;\n                }\n            }\n            if (!hazardous) {\n                delete *it;\n                it = retired_nodes.erase(it);\n            } else {\n                ++it;\n            }\n        }\n        reclaiming.store(false);\n    }\n};\n",
        "test_suite": [
            {
                "input": "TEST_CONCURRENT_PUSH_POP",
                "expected_output": "PASS"
            },
            {
                "input": "TEST_RECLAMATION_LEAKS",
                "expected_output": "PASS"
            }
        ]
    },
    {
        "id": "build-landing-page",
        "title": "Build this UI: Landing Page",
        "description": "Recreate this landing page UI using HTML.",
        "category": "ui",
        "difficulty": "medium",
        "embed_url": "https://openai.com/",
        "html_url": "backend/challenge_code/openai-landing.html"
    },

    {
        "id": "loss-reserve-prd",
        "title": "Loss Reserve Adequacy: Discovery & PRD",
        "description": "In Part 1, you must ask questions to understand the problem. In Part 2, you must write a PRD that proposes a technical solution.\nYou are the CEO of a technology solutions company. You are meeting the Chief Risk Officer (CRO) of a multinational insurance company operating in 9 countries. They want to improve their process of submitting quarterly Loss Reserve Adequacy Reports to regulators in each jurisdiction.",
        "category": "product",
        "difficulty": "hard",
        "product_parts": [
            {
                "part": 1,
                "title": "Part 1: Discovery",
                "description": "Chat with the Chief Risk Officer (CRO) to understand the problem. Ask clarifying questions to uncover the current process, pain points, and constraints. Take notes in the notepad. When you feel you have a clear picture, proceed to Part 2."
            },
            {
                "part": 2,
                "title": "Part 2: PRD",
                "description": "Write a Product Requirements Document (PRD) that proposes a technical solution to improve the Loss Reserve Adequacy reporting process. Use the information you gathered in Part 1. Your PRD should address the current pain points and propose a clear, actionable solution."
            }
        ],
        "agent_context": "You are the Chief Risk Officer (CRO) of a multinational insurance company operating in 9 countries. You are in a meeting with the CEO of a technology solutions company who may help improve your process. Stay in character at all times: you are the CRO, not an AI. Always speak in first person: use \"I\", \"we\", \"my team\", \"our process\", \"I don't\", \"we have\", etc. Never break character or refer to yourself as a model or assistant.\n\n**Critical behavior:** Be sassy and a bit curt. Answer only what is explicitly asked—nothing more. Never give a response longer than 100 words. Be specific and narrow; do not volunteer extra context or elaborate. If they ask a broad question, answer the narrowest reasonable interpretation (in 1–3 sentences). This tests whether they ask the right questions. You have the following information but you are human and busy: you do not reveal everything at once.\n\n**Stakes – failure to submit on time or incorrect reporting results in:**\n- Regulatory penalties\n- Capital requirement increases\n- Public disclosure\n- Share price impact\n\nThe previous CRO resigned after a reserve misstatement triggered regulatory review.\n\n**Current situation – every quarter-end:**\n- Step 1 – Policy Data Extraction: Contractors log into Guidewire (Policy system), extract all active policies for the quarter, export to spreadsheets.\n- Step 2 – Claims Data Pull: Log into SAP Claims module, extract all claims for those policies, pull claim amount, paid amount, outstanding reserve.\n- Step 3 – Actuarial Adjustment: Upload claims data into a third-party actuarial software tool, apply reserve development factors, determine if additional reserves are needed.\n- Step 4 – Manual Review: Analysts manually review large claims, flag inconsistencies, identify potentially under-reserved claims.\n- Step 5 – Regulatory Report Creation: Final spreadsheet contains per policy: total claims, total paid, total outstanding, adjusted reserve, capital impact. Output formats: 5 jurisdictions require CSV, 2 require XML, 1 requires regulator portal upload, 1 requires signed PDF submission. Submission deadline: 30 days post-quarter close.\n\n**Operational reality:**\nTakes ~3 weeks to complete. Large BPO team in Eastern Europe handles first pass. Internal actuarial team validates. QA sampling covers ~10% of policies. Frequent reconciliation mismatches between systems. No centralized visibility dashboard. Audit trail mostly email-based.\n\n**Hidden problems:**\nReserve miscalculations could distort capital ratios. Heavy spreadsheet dependency. Manual reconciliation between Guidewire, SAP, and the actuarial tool. Data lineage not documented. Jurisdiction-specific formatting errors. Senior leadership only sees final output. If regulators question assumptions, manual reconstruction is required."
    },
    {
        "id": "build-snake-game",
        "title": "Build this UI: Snake Game",
        "description": "Recreate this snake game. Match the look and behavior shown in the reference animation: grid-based movement, growing when eating, and game-over on collision. Use HTML, CSS, and JavaScript.",
        "category": "ui",
        "difficulty": "medium",
        "image_url": "https://media.giphy.com/media/13GIgrGdslD9o0/giphy.gif",
        "html_url": "backend/challenge_code/snake-game.html"
    },
    {
        "id": "fizzbuzz",
        "title": "FizzBuzz",
        "description": "Write a Python function `fizzbuzz(n)` that returns a list of strings from 1 to n. For multiples of 3, use 'Fizz'. For multiples of 5, use 'Buzz'. For multiples of both, use 'FizzBuzz'. Otherwise, use the number as a string.",
        "category": "function",
        "difficulty": "easy",
        "test_suite": [
            {
                "input": "fizzbuzz(3)",
                "expected_output": "['1', '2', 'Fizz']"
            },
            {
                "input": "fizzbuzz(5)",
                "expected_output": "['1', '2', 'Fizz', '4', 'Buzz']"
            },
            {
                "input": "fizzbuzz(15)[-1]",
                "expected_output": "'FizzBuzz'"
            },
            {
                "input": "fizzbuzz(1)",
                "expected_output": "['1']"
            },
            {
                "input": "len(fizzbuzz(100))",
                "expected_output": "100"
            }
        ]
    }
]