[
    {
        "id": "cpp-lockfree-stack",
        "title": "Debug: Lock-Free Stack Race Conditions",
        "description": "This lock-free stack implementation uses a simplified Hazard Pointer scheme but crashes under high contention due to race conditions and memory reclamation bugs. Fix the race conditions while maintaining lock-free properties.",
        "category": "debug",
        "difficulty": "hard",
        "starter_code": "#include <atomic>\n#include <vector>\n#include <thread>\n#include <iostream>\n\n// A simplified Hazard Pointer Node\nstruct Node {\n    int value;\n    Node* next;\n    Node(int v) : value(v), next(nullptr) {}\n};\n\n// Global Hazard Pointers (simplified for fixed thread count)\nstd::atomic<Node*> hazard_pointers[100]; \nconst int MAX_THREADS = 100;\n\nclass LockFreeStack {\n    std::atomic<Node*> head{nullptr};\n    std::vector<Node*> retired_nodes; \n    std::atomic<bool> reclaiming{false};\n\npublic:\n    void push(int val) {\n        Node* new_node = new Node(val);\n        new_node->next = head.load(std::memory_order_relaxed);\n        while (!head.compare_exchange_weak(new_node->next, new_node, \n                                           std::memory_order_release, \n                                           std::memory_order_relaxed));\n    }\n\n    bool pop(int& result, int thread_id) {\n        Node* old_head;\n        do {\n            old_head = head.load(std::memory_order_relaxed);\n            if (!old_head) return false;\n            \n            hazard_pointers[thread_id].store(old_head, std::memory_order_seq_cst);\n            \n            if (head.load(std::memory_order_relaxed) != old_head) {\n                hazard_pointers[thread_id].store(nullptr, std::memory_order_relaxed); \n                continue;\n            }\n        } while (!head.compare_exchange_weak(old_head, old_head->next, \n                                             std::memory_order_acquire, \n                                             std::memory_order_relaxed));\n        \n        hazard_pointers[thread_id].store(nullptr, std::memory_order_relaxed);\n        result = old_head->value;\n        retire(old_head);\n        return true;\n    }\n\n    void retire(Node* node) {\n        retired_nodes.push_back(node); \n        \n        if (reclaiming.exchange(true)) return;\n        \n        for (auto it = retired_nodes.begin(); it != retired_nodes.end(); ) {\n            bool hazardous = false;\n            for (int i = 0; i < MAX_THREADS; ++i) {\n                if (hazard_pointers[i].load() == *it) {\n                    hazardous = true;\n                    break;\n                }\n            }\n            if (!hazardous) {\n                delete *it;\n                it = retired_nodes.erase(it);\n            } else {\n                ++it;\n            }\n        }\n        reclaiming.store(false);\n    }\n};\n",
        "test_suite": [
            {
                "input": "TEST_CONCURRENT_PUSH_POP",
                "expected_output": "PASS"
            },
            {
                "input": "TEST_RECLAMATION_LEAKS",
                "expected_output": "PASS"
            }
        ]
    },
    {
        "id": "build-landing-page",
        "title": "Build this UI: Landing Page",
        "description": "Recreate this landing page UI using HTML.",
        "category": "ui",
        "difficulty": "medium",
        "embed_url": "https://openai.com/",
        "html_url": "backend/challenge_code/openai-landing.html"
    },
    {
        "id": "build-snake-game",
        "title": "Build this UI: Snake Game",
        "description": "Recreate this snake game. Match the look and behavior shown in the reference animation: grid-based movement, growing when eating, and game-over on collision. Use HTML, CSS, and JavaScript.",
        "category": "ui",
        "difficulty": "medium",
        "image_url": "https://media.giphy.com/media/13GIgrGdslD9o0/giphy.gif",
        "html_url": "backend/challenge_code/snake-game.html"
    },
    {
        "id": "fizzbuzz",
        "title": "FizzBuzz",
        "description": "Write a Python function `fizzbuzz(n)` that returns a list of strings from 1 to n. For multiples of 3, use 'Fizz'. For multiples of 5, use 'Buzz'. For multiples of both, use 'FizzBuzz'. Otherwise, use the number as a string.",
        "category": "function",
        "difficulty": "easy",
        "test_suite": [
            {
                "input": "fizzbuzz(3)",
                "expected_output": "['1', '2', 'Fizz']"
            },
            {
                "input": "fizzbuzz(5)",
                "expected_output": "['1', '2', 'Fizz', '4', 'Buzz']"
            },
            {
                "input": "fizzbuzz(15)[-1]",
                "expected_output": "'FizzBuzz'"
            },
            {
                "input": "fizzbuzz(1)",
                "expected_output": "['1']"
            },
            {
                "input": "len(fizzbuzz(100))",
                "expected_output": "100"
            }
        ]
    },
    {
        "id": "debug-lis",
        "title": "Debug: Longest Increasing Subsequence",
        "description": "The following function is supposed to return the length of the longest STRICTLY increasing subsequence, but it has a subtle bug. It produces correct results for many inputs but fails on others.\n\nFind and fix the bug. Your fixed function must be named `longest_increasing_subsequence`.",
        "category": "debug",
        "difficulty": "easy",
        "starter_code": "import bisect\n\ndef longest_increasing_subsequence(nums):\n    if not nums:\n        return 0\n    tails = []\n    for num in nums:\n        pos = bisect.bisect_right(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    return len(tails)\n",
        "target_code": "import bisect\n\ndef longest_increasing_subsequence(nums):\n    if not nums:\n        return 0\n    tails = []\n    for num in nums:\n        pos = bisect.bisect_left(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    return len(tails)\n",
        "test_suite": [
            {
                "input": "longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18])",
                "expected_output": "4"
            },
            {
                "input": "longest_increasing_subsequence([1, 2, 3, 4, 5])",
                "expected_output": "5"
            },
            {
                "input": "longest_increasing_subsequence([7, 7, 7, 7, 7])",
                "expected_output": "1"
            },
            {
                "input": "longest_increasing_subsequence([3, 1, 2, 1, 2, 3])",
                "expected_output": "3"
            },
            {
                "input": "longest_increasing_subsequence([1, 1, 1, 2, 2, 3])",
                "expected_output": "3"
            },
            {
                "input": "longest_increasing_subsequence([])",
                "expected_output": "0"
            }
        ]
    },
    {
        "id": "nyt-front-page-scraper",
        "title": "NYT Front Page Scraper",
        "description": "Build a web scraper that grabs all the articles on the NYT front page (https://www.nytimes.com). Extract article titles, URLs, and optionally summaries or bylines. Return structured data (e.g. JSON or list of dicts). Use Python with requests/BeautifulSoup, or another language of your choice.",
        "category": "data",
        "difficulty": "medium"
    }
]